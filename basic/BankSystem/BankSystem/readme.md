
### Основные классы системы

| Класс | Описание |
|------|---------|
| **Bank** | Главный класс — представляет банк. Хранит списки: <br>• клиентов <br>• счетов <br>• операций |
| **Account** | Класс счёта. **Нельзя создать напрямую** — только через метод `createAccount()` в классе `Bank`. Это гарантирует, что каждый счёт принадлежит банку. |
| **Client** | Класс клиента. Хранит имя и паспорт. Если клиент уже есть — не создаётся заново. |
| **Operation** | **Абстрактный класс** — основа для всех операций. Содержит: <br>• `amount` — сумма операции <br>• `doWork()` — метод, выполняющий операцию |
| **AccountOperation** | Операция **на одном счёте** (пополнение/списание). |
| **CrossAccountOperation** | Операция **между счетами** (перевод). |
| **OperationException** | Исключение, которое возникает при ошибках в операциях (например, не хватает денег). |

---

### Как работает создание счёта

- Счёт создаётся **только через `Bank.createAccount()`**.
- Если клиент с таким паспортом уже есть — используем его.
- Если нет — создаём нового клиента.
- Счёт добавляется в список счетов банка.

---

### Выполнение операций

1. Добавляем операции в банк: `bank.addOperation(...)`
2. Запускаем все операции: `bank.runOperations()`
   - Каждая операция выполняется через `doWork()`
   - Если ошибка — ловим `OperationException` и выводим сообщение
3. После выполнения список операций очищается.

---

## Пример кода (упрощённо)

```java
Bank bank = new Bank();

Bank.Account acc1 = bank.createAccount("Иванов", "АК123456");        // баланс 0
Bank.Account acc2 = bank.createAccount("Петров", "АЕ123456", 50);   // баланс 50

Operation op1 = new AccountOperation(acc1, 100);         // +100 на acc1
Operation op2 = new CrossAccountOperation(acc2, acc1, 10); // перевод 10 с acc2 на acc1

bank.addOperation(op1);
bank.addOperation(op2);

bank.runOperations(); // выполняем
System.out.print(bank); // выводим состояние счетов
```

---

## Домашнее задание

### 1. Заменить `Vector<Client>` на своё **бинарное дерево поиска** — `Tree<T>`

- Создайте **универсальный класс** `Tree<T>` — бинарное дерево.
- Используйте его вместо `Vector<Client>` для хранения клиентов.
- Проблема: Java не знает, как сравнивать объекты типа `T`.
- **Решение**: используйте интерфейс `Comparator<T>` для сравнения клиентов (например, по паспорту).

> Пример ошибки, если не использовать `Comparator`:
> ```java:disable-run
> class GenericTest<T> {
>     T a, b;
>     boolean aIsGreater() { return a > b; } // ОШИБКА! Нельзя сравнить T
> }
> ```

---

### 2. Логирование ошибок операций

Нужно **сохранять все ошибки**, которые произошли при выполнении операций.

**Требования:**
- Ошибка = `(Дата + время, Сообщение)`
- Должна быть возможность **добавлять ошибки из любого места программы**
- Единый (унифицированный) способ обработки ошибок

**Что нужно сделать:**
1. Создать класс `BankError`:
   ```java
   class BankError {
       LocalDateTime timestamp;
       String message;
   }
   ```
2. Добавить в `Bank` список ошибок: `List<BankError> errors`
3. При ловле `OperationException` — **сохранять ошибку в лог**
4. Сделать **статический класс-логгер** (например, `ErrorLogger`), чтобы можно было писать:
   ```java
   ErrorLogger.log("Не хватает денег на счёте X");
   ```
   — и это работало **из любого класса**.

---

## Цель

Сделать систему:
- Более гибкой (дерево вместо списка)
- Надёжной (все ошибки логируются)
- Расширяемой (легко добавлять новые операции)

