### 1) Тема: Запуск и завершение user-потоков (Thread как user-thread)

2) Примеры:  
- **MainFiniteLoop.java:** Создание и запуск MyThread1 в main с конечным циклом (10000 итераций с печатью точек).  
- **MainInfiniteLoop.java:** Запуск MyThread1 в main с бесконечным циклом (печать точек без выхода).

3) Объяснение темы:  
User-потоки (по умолчанию) продолжают выполнение даже после завершения main, блокируя JVM от выхода, пока все user-threads не завершатся. Это полезно для фоновых задач, но может привести к "зависанию" программы, если поток бесконечен. В finite main поток прерывается при завершении JVM; в infinite — программа не завершается, чередуя выводы. Такие потоки обеспечивают независимость от main, но требуют явного управления (interrupt/join) для контроля.

4) Основные методы и особенности:  
- **Thread.start():** Инициация выполнения run() в отдельном потоке; не блокирует caller.  
- **run():** Точка входа потока (в MyThread1: while(true) с print("A")); переопределение для логики.  
- **Thread.join() / interrupt():** Ожидание завершения или прерывание (не используются здесь, но рекомендуются для graceful shutdown).  
- Особенности: User-threads держат JVM живой; preemptiv scheduling ОС; возможен deadlock без синхронизации; выводы interleaving из-за time-slicing (точки и "A" перемешиваются).

### 2) Тема: Daemon-потоки (фоновые потоки)

2) Пример:  
- **MainWithDaemon.java:** Создание MyThread1 как daemon (setDaemon(true)), запуск в main с конечным циклом.

3) Объяснение темы:  
Daemon-потоки — это служебные (background) потоки, которые не предотвращают завершение JVM: программа exits, когда все user-threads (включая main) завершены, автоматически останавливая daemons. Это идеально для мониторинга, logging или cleanup, где поток не критичен. В примере daemon печатает "A" во время finite main, но прекращает при его завершении, без ожидания.

4) Основные методы и особенности:  
- **Thread.setDaemon(boolean):** Установка флага до start() (true для daemon); нельзя изменить после запуска.  
- **isDaemon():** Проверка статуса (false по умолчанию для new Thread).  
- **start():** Запуск; daemon не влияет на lifecycle caller.  
- Особенности: Автоматическое завершение без interrupt; не подходит для critical задач (риск потери данных); наследуется дочерними потоками; в выводе — "A" прерывается после точек.

### 3) Тема: Приоритет потоков (Thread Priority)

2) Пример:  
- **MainWithMinPriority.java:** Создание daemon MyThread1 с минимальным приоритетом (setPriority(MIN_PRIORITY)), запуск в finite main.

3) Объяснение темы:  
Приоритет (1-10, NORM_PRIORITY=5) влияет на scheduling: higher priority потоки чаще получают CPU-time в preemptiv системах. MIN_PRIORITY (1) минимизирует влияние daemon на main, позволяя основному потоку доминировать. Это полезно для баланса нагрузки, но не гарантирует (зависит от ОС); в примере low-priority daemon реже печатает "A", фокусируясь на точках main.

4) Основные методы и особенности:  
- **Thread.setPriority(int):** Установка уровня (MIN=1, MAX=10, NORM=5); до start().  
- **getPriority():** Получение текущего (по умолчанию NORM для user-threads).  
- **yield() / sleep():** Добровольная уступка CPU (не в примере, но усиливает приоритет).  
- Особенности: Hint для scheduler, не strict (ОС может игнорировать); daemon с low priority ускоряет main; возможен starvation high-priority; мониторить через ThreadMXBean для production.