# Домашнее задание: Чтение и обработка данных о странах и столицах с использованием потоков

Это домашнее задание посвящено работе с потоками ввода-вывода (I/O), многопоточностью, коллекциями и сортировкой в Java. Основная цель — создать простое приложение, которое асинхронно читает данные из двух файлов, синхронизирует их чтение, формирует объекты с информацией о странах и столицах, а затем сортирует и выводит результаты. Задание подчеркивает использование синхронизации потоков, лямбда-выражений и анонимных классов для повышения эффективности и читаемости кода.

Задание разделено на этапы: подготовка данных, разработка класса, реализация логики чтения с потоками, обработка коллекции и вывод результатов. Ниже приведено подробное структурированное описание.

## 1. Подготовка входных данных
Перед написанием кода необходимо создать два текстовых файла. Это обеспечит данные для тестирования приложения.

### Требования к файлам:
- **countries.txt**: Содержит список названий стран (минимум 10 записей).
  - Пример содержимого (разделитель — пробел, но можно выбрать любой, например, запятую или новую строку):
    ```
    Austria China Brazil Netherlands Canada France Germany Italy Japan Spain
    ```
- **capitals.txt**: Содержит список названий столиц в той же последовательности, что и страны в первом файле (минимум 10 записей).
  - Пример содержимого:
    ```
    Vienna Beijing Brasilia Amsterdam Ottawa Paris Berlin Rome Tokyo Madrid
    ```
- **Рекомендации**:
  - Используйте не менее 10 пар (страна + столица) для демонстрации масштаба.
  - Разделитель: Можно использовать пробелы, запятые, табуляцию или новую строку (каждое значение в отдельной строке для простоты парсинга).
  - Файлы должны быть в кодировке UTF-8, чтобы избежать проблем с русскими или специальными символами.
  - Разместите файлы в корневой директории проекта или укажите полный путь в коде.

## 2. Определение класса CountryInfo
Создайте класс для хранения пары "страна — столица". Это будет основная сущность для коллекции.

### Структура класса:
```java
public class CountryInfo {
    private String country;  // Название страны
    private String capital;  // Название столицы

    // Конструктор
    public CountryInfo(String country, String capital) {
        this.country = country;
        this.capital = capital;
    }

    // Геттеры и сеттеры
    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public String getCapital() {
        return capital;
    }

    public void setCapital(String capital) {
        this.capital = capital;
    }

    // Метод toString() для удобного вывода
    @Override
    public String toString() {
        return "CountryInfo{" +
                "country='" + country + '\'' +
                ", capital='" + capital + '\'' +
                '}';
    }
}
```
- **Расширение**: Добавьте Comparable для упрощения сортировки или реализуйте интерфейс Comparator в лямбда-выражениях (см. ниже).

## 3. Реализация логики чтения с использованием потоков
Приложение должно использовать **два отдельных потока** (threads) для чтения файлов. Чтение должно быть синхронизировано: первый поток читает страну, передает "эстафету" второму, который читает столицу. После пары создается объект `CountryInfo` и добавляется в коллекцию.

### Ключевые принципы:
- **Потоки**: Один поток для `countries.txt` (CountryReaderThread), другой для `capitals.txt` (CapitalReaderThread).
- **Синхронизация**: Используйте механизмы вроде `synchronized`, `wait()/notify()`, `Semaphore`, `BlockingQueue` или `CountDownLatch` для координации. Поток стран "ждет" после чтения, пока поток столиц не прочитает и не подтвердит.
- **Коллекция**: Выберите `List<CountryInfo>` (например, `ArrayList`) для хранения объектов. Доступ к коллекции должен быть thread-safe (используйте `Collections.synchronizedList` или синхронизированные блоки).
- **Лямбда-выражения и анонимные классы**: Используйте для создания потоков (например, `new Thread(() -> { ... })`) и Runnable.

### Шаги реализации:
1. **Чтение файлов**:
   - Используйте `BufferedReader` или `Files.lines()` (Java 8+) для чтения строк или токенов.
   - Парсинг: Если разделитель — пробел, используйте `String.split("\\s+")`; если новая строка — читайте по одной.

2. **Создание потоков**:
   - **Поток 1 (страны)**: Читает страну, добавляет в общую очередь/переменную, вызывает `notify()` для потока столиц, затем `wait()`.
   - **Поток 2 (столицы)**: Ждет сигнала, читает столицу, создает `CountryInfo`, добавляет в коллекцию, возвращает эстафету.
   - Обеспечьте обработку конца файлов (EOF) с помощью `hasNext()` или try-with-resources.

3. **Пример псевдокода**:
   ```java
   List<CountryInfo> collection = Collections.synchronizedList(new ArrayList<>());
   Object lock = new Object();  // Для синхронизации

   Thread countryThread = new Thread(() -> {
       try (BufferedReader reader = Files.newBufferedReader(Paths.get("countries.txt"))) {
           String line;
           while ((line = reader.readLine()) != null) {
               String country = line.trim();  // Парсинг
               synchronized (lock) {
                   // Сохранить страну
                   lock.wait();  // Ждать столицы? Нет: по задаче — страна ждет столицу
                   // Адаптировать под эстафету
               }
           }
       } catch (IOException | InterruptedException e) { /* Обработка */ }
   });

   // Аналогично для capitalThread

   countryThread.start();
   capitalThread.start();
   // Ждать завершения: countryThread.join(); capitalThread.join();
   ```

- **Варианты синхронизации**:
  - Простой: `synchronized` блоки с общим объектом-замком.
  - Продвинутый: `ExecutorService` с `submit()` и `Future` для управления задачами.
  - Обеспечьте, чтобы чтение шло поочередно до конца обоих файлов (предполагается равное количество записей).

## 4. Сортировка и вывод коллекции
После завершения чтения обработайте коллекцию.

### Шаги:
1. **Сортировка по полю `country`** (алфавитный порядок):
   - Используйте `Collections.sort(collection, Comparator.comparing(CountryInfo::getCountry))` (лямбда).

2. **Вывод на экран**:
   - Переберите коллекцию и выведите каждый объект с помощью `System.out.println(info)`.

3. **Сортировка по полю `capital`** (алфавитный порядок):
   - Аналогично: `Collections.sort(collection, Comparator.comparing(CountryInfo::getCapital))`.

4. **Второй вывод**:
   - Снова переберите и выведите.

### Пример вывода:
```
После сортировки по country:
CountryInfo{country='Austria', capital='Vienna'}
CountryInfo{country='Brazil', capital='Brasilia'}
...

После сортировки по capital:
CountryInfo{country='Netherlands', capital='Amsterdam'}
CountryInfo{country='China', capital='Beijing'}
...
```

## 5. Общие рекомендации и лучшие практики
- **Исключения**: Обрабатывайте `IOException` для файлов и `InterruptedException` для потоков.
- **Thread-safety**: Всегда синхронизируйте доступ к коллекции и общим ресурсам.
- **Лямбды и анонимные классы**: Применяйте для Comparator, Runnable и Stream API (если используете для чтения: `Files.lines().map(...)`).
- **Тестирование**: Запустите с разными разделителями и количествами записей. Проверьте на равенство длин файлов (если не совпадают — добавьте логику обработки).
- **Расширения**: Добавьте GUI (Swing) для вывода или сохраните коллекцию в JSON/CSV.
- **Инструменты**: Используйте IDE (IntelliJ/Eclipse) для отладки потоков. Для многопоточности — визуализаторы вроде VisualVM.

Это задание развивает навыки concurrency, I/O и коллекций. Если реализовать аккуратно, код будет компактным и эффективным! Если нужны примеры кода или уточнения, спросите.